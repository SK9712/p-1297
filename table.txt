import { Component, Input, OnInit, OnChanges, SimpleChanges, ViewChild, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

// Angular Material Imports
import { MatTableModule, MatTableDataSource } from '@angular/material/table';
import { MatSortModule, MatSort } from '@angular/material/sort';
import { MatPaginatorModule, MatPaginator } from '@angular/material/paginator';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatDialogModule, MatDialog } from '@angular/material/dialog';
import { MatChipsModule } from '@angular/material/chips';
import { MatCardModule } from '@angular/material/card';

export interface TableColumn {
  key: string;
  label: string;
  type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'nested';
  sortable: boolean;
  width?: string;
  nestedColumns?: TableColumn[];
  maxDepth?: number;
}

export interface NestedViewConfig {
  enableNestedExpansion: boolean;
  maxDepth: number;
  flattenArrays: boolean;
  showArrayIndices: boolean;
}

@Component({
  selector: 'app-json-content',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatTableModule,
    MatSortModule,
    MatPaginatorModule,
    MatFormFieldModule,
    MatInputModule,
    MatIconModule,
    MatButtonModule,
    MatProgressSpinnerModule,
    MatExpansionModule,
    MatTooltipModule,
    MatDialogModule,
    MatChipsModule,
    MatCardModule
  ],
  templateUrl: './json-content.component.html',
  styleUrls: ['./json-content.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class JsonContentComponent implements OnInit, OnChanges {
  @Input() 
  set jsonData(value: string[] | any[] | undefined | null) {
    if (!value) {
      this._rawJsonData = [];
      this._parsedJsonData = [];
    } else if (this.isStringArray(value)) {
      this._rawJsonData = value as string[];
      this._parsedJsonData = this.parseJsonStrings(this._rawJsonData);
    } else {
      this._rawJsonData = [];
      this._parsedJsonData = value as any[];
    }
    
    if (this._initialized) {
      this.applyStartIndexAndInitialize();
    }
  }
  
  get jsonData(): any[] {
    return this._displayedData;
  }

  @Input() 
  set startIndex(value: number | undefined) {
    this._startIndex = value || 1;
    if (this._initialized) {
      this.applyStartIndexAndInitialize();
    }
  }
  
  get startIndex(): number {
    return this._startIndex;
  }

  // New inputs for nested functionality
  @Input() nestedConfig: NestedViewConfig = {
    enableNestedExpansion: true,
    maxDepth: 3,
    flattenArrays: false,
    showArrayIndices: true
  };

  @Input() enableNestedView: boolean = true;
  @Input() flattenNestedObjects: boolean = false;
  @Input() arrayDisplayMode: 'preview' | 'count' | 'expanded' = 'preview';
  
  private _rawJsonData: string[] = [];
  private _parsedJsonData: any[] = [];
  private _displayedData: any[] = [];
  private _flattenedData: any[] = [];
  private _startIndex: number = 1;
  private _initialized = false;

  // Existing properties
  @Input() pageSize: number = 25;
  @Input() pageSizeOptions: number[] = [10, 25, 50, 100];
  @Input() enableSearch: boolean = true;
  @Input() enableExport: boolean = true;
  @Input() maxColumnWidth: number = 250;
  @Input() showSchemaPanel: boolean = true;

  @ViewChild(MatSort) sort!: MatSort;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  dataSource = new MatTableDataSource<any>([]);
  columns: TableColumn[] = [];
  displayedColumns: string[] = [];
  searchQuery: string = '';
  isLoading: boolean = false;
  totalRecords: number = 0;
  filteredRecords: number = 0;
  expandedRows = new Set<number>();

  constructor(
    private cdr: ChangeDetectorRef,
    private dialog: MatDialog
  ) {}

  // Static methods for external use
  static convertJsonStringsToObjects(jsonStrings: string[]): any[] {
    const parsedObjects: any[] = [];
    
    jsonStrings.forEach((jsonString, index) => {
      try {
        if (jsonString && typeof jsonString === 'string') {
          const trimmed = jsonString.trim();
          if (trimmed) {
            const parsed = JSON.parse(trimmed);
            parsedObjects.push(parsed);
          }
        }
      } catch (error) {
        console.warn(`Failed to parse JSON at index ${index}:`, error);
        parsedObjects.push({
          _parseError: true,
          _errorMessage: error instanceof Error ? error.message : 'Unknown parsing error',
          _originalString: jsonString?.substring(0, 100) + (jsonString?.length > 100 ? '...' : ''),
          _index: index
        });
      }
    });

    return parsedObjects;
  }

  // New static method for flattening nested objects
  static flattenObject(obj: any, prefix: string = '', maxDepth: number = 3, currentDepth: number = 0): any {
    const flattened: any = {};
    
    if (currentDepth >= maxDepth) {
      flattened[prefix || 'root'] = obj;
      return flattened;
    }

    if (obj === null || obj === undefined) {
      flattened[prefix || 'value'] = obj;
      return flattened;
    }

    if (typeof obj !== 'object' || obj instanceof Date) {
      flattened[prefix || 'value'] = obj;
      return flattened;
    }

    if (Array.isArray(obj)) {
      obj.forEach((item, index) => {
        const newPrefix = prefix ? `${prefix}[${index}]` : `[${index}]`;
        const flattened_item = JsonContentComponent.flattenObject(item, newPrefix, maxDepth, currentDepth + 1);
        Object.assign(flattened, flattened_item);
      });
      return flattened;
    }

    Object.keys(obj).forEach(key => {
      const newPrefix = prefix ? `${prefix}.${key}` : key;
      const flattened_value = JsonContentComponent.flattenObject(obj[key], newPrefix, maxDepth, currentDepth + 1);
      Object.assign(flattened, flattened_value);
    });

    return flattened;
  }

  // Public methods
  getConvertedData(): any[] {
    return this._parsedJsonData;
  }

  getOriginalJsonStrings(): string[] {
    return this._rawJsonData;
  }

  getFlattenedData(): any[] {
    return this._flattenedData;
  }

  ngOnInit(): void {
    this._initialized = true;
    this.applyStartIndexAndInitialize();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if ((changes['jsonData'] || changes['startIndex'] || changes['flattenNestedObjects'] || changes['nestedConfig']) && this._initialized) {
      this.applyStartIndexAndInitialize();
    }
  }

  private applyStartIndexAndInitialize(): void {
    if (!this._parsedJsonData || this._parsedJsonData.length === 0) {
      this._displayedData = [];
      this._flattenedData = [];
      this.initializeTable();
      return;
    }

    const startIdx = Math.max(0, this._startIndex - 1);
    this._displayedData = this._parsedJsonData.slice(startIdx);
    
    // Create flattened version if needed
    if (this.flattenNestedObjects || this.nestedConfig.enableNestedExpansion) {
      this._flattenedData = this._displayedData.map(item => 
        JsonContentComponent.flattenObject(item, '', this.nestedConfig.maxDepth)
      );
    }
    
    console.log(`Applied startIndex ${this._startIndex} (0-based: ${startIdx})`);
    console.log(`Original data length: ${this._parsedJsonData.length}`);
    console.log(`Displayed data length: ${this._displayedData.length}`);
    
    this.initializeTable();
  }

  private isStringArray(value: any): boolean {
    return Array.isArray(value) && value.length > 0 && typeof value[0] === 'string';
  }

  private parseJsonStrings(jsonStrings: string[]): any[] {
    return JsonContentComponent.convertJsonStringsToObjects(jsonStrings);
  }

  private initializeTable(): void {
    console.log('Initializing table with displayed data:', this._displayedData);
    
    if (!this._displayedData || this._displayedData.length === 0) {
      console.log('No displayed data available for table');
      this.resetTable();
      this.cdr.markForCheck();
      return;
    }

    this.isLoading = true;
    this.cdr.markForCheck();
    
    setTimeout(() => {
      try {
        // Use flattened data if flattening is enabled, otherwise use original
        const schemaData = this.flattenNestedObjects ? this._flattenedData[0] : this._displayedData[0];
        const tableData = this.flattenNestedObjects ? this._flattenedData : this._displayedData;
        
        console.log('Schema data:', schemaData);
        this.columns = this.generateSchema(schemaData);
        console.log('Generated columns:', this.columns);
        this.displayedColumns = this.columns.map(col => col.key);
        console.log('Displayed columns:', this.displayedColumns);
        
        this.dataSource.data = tableData;
        this.totalRecords = tableData.length;
        this.filteredRecords = tableData.length;
        
        console.log('Data source set with', this.totalRecords, 'records (after startIndex applied)');
        
        setTimeout(() => {
          if (this.sort) {
            this.dataSource.sort = this.sort;
          }
          if (this.paginator) {
            this.dataSource.paginator = this.paginator;
          }
          this.dataSource.filterPredicate = this.createFilter();
          this.cdr.markForCheck();
        });
        
      } catch (error) {
        console.error('Error initializing table:', error);
        this.resetTable();
      } finally {
        this.isLoading = false;
        this.cdr.markForCheck();
      }
    });
  }

  private generateSchema(firstRecord: any): TableColumn[] {
    console.log('Generating schema for record:', firstRecord);
    
    if (!firstRecord || typeof firstRecord !== 'object') {
      console.warn('Invalid first record for schema generation:', firstRecord);
      return [];
    }

    const schema: TableColumn[] = [];
    
    Object.keys(firstRecord).forEach(key => {
      const value = firstRecord[key];
      const column: TableColumn = {
        key: key,
        label: this.formatColumnLabel(key),
        type: this.detectFieldType(value),
        sortable: this.isSortable(value),
        width: this.getOptimalColumnWidth(key, value),
        maxDepth: this.calculateNestingDepth(value)
      };

      // Generate nested columns for complex objects
      if (column.type === 'object' && this.enableNestedView) {
        column.nestedColumns = this.generateNestedSchema(value, 1);
      }

      schema.push(column);
      console.log(`Generated column for key '${key}':`, column);
    });

    console.log('Final schema:', schema);
    return schema;
  }

  private generateNestedSchema(obj: any, depth: number): TableColumn[] {
    if (depth >= this.nestedConfig.maxDepth || !obj || typeof obj !== 'object') {
      return [];
    }

    const nestedSchema: TableColumn[] = [];
    
    Object.keys(obj).forEach(key => {
      const value = obj[key];
      const column: TableColumn = {
        key: key,
        label: this.formatColumnLabel(key),
        type: this.detectFieldType(value),
        sortable: this.isSortable(value),
        width: this.getOptimalColumnWidth(key, value),
        maxDepth: this.calculateNestingDepth(value)
      };

      if (column.type === 'object' && depth < this.nestedConfig.maxDepth - 1) {
        column.nestedColumns = this.generateNestedSchema(value, depth + 1);
      }

      nestedSchema.push(column);
    });

    return nestedSchema;
  }

  private calculateNestingDepth(obj: any, currentDepth: number = 0): number {
    if (!obj || typeof obj !== 'object' || currentDepth >= 10) {
      return currentDepth;
    }

    if (Array.isArray(obj)) {
      return obj.length > 0 ? this.calculateNestingDepth(obj[0], currentDepth + 1) : currentDepth + 1;
    }

    let maxDepth = currentDepth;
    Object.values(obj).forEach(value => {
      const depth = this.calculateNestingDepth(value, currentDepth + 1);
      maxDepth = Math.max(maxDepth, depth);
    });

    return maxDepth;
  }

  private detectFieldType(value: any): TableColumn['type'] {
    if (value === null || value === undefined) {
      return 'string';
    }

    if (typeof value === 'boolean') {
      return 'boolean';
    }

    if (typeof value === 'number') {
      return 'number';
    }

    if (Array.isArray(value)) {
      return 'array';
    }

    if (value instanceof Date || this.isDateString(value)) {
      return 'date';
    }

    if (typeof value === 'object') {
      // Check if it's a nested object with multiple levels
      const depth = this.calculateNestingDepth(value);
      return depth > 1 ? 'nested' : 'object';
    }

    return 'string';
  }

  private isDateString(value: any): boolean {
    if (typeof value !== 'string') return false;
    
    const dateRegex = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:\d{2})?)?$/;
    return dateRegex.test(value) && !isNaN(Date.parse(value));
  }

  private isSortable(value: any): boolean {
    const type = this.detectFieldType(value);
    return ['string', 'number', 'boolean', 'date'].includes(type);
  }

  private formatColumnLabel(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/_/g, ' ')
      .replace(/\./g, ' → ')
      .replace(/\[(\d+)\]/g, ' [$1]')
      .replace(/\b\w/g, l => l.toUpperCase())
      .trim();
  }

  private getOptimalColumnWidth(key: string, value: any): string {
    const type = this.detectFieldType(value);
    
    switch (type) {
      case 'boolean':
        return '90px';
      case 'number':
        return '130px';
      case 'date':
        return '180px';
      case 'array':
        return '150px';
      case 'object':
        return '120px';
      case 'nested':
        return '200px';
      default:
        const estimatedWidth = Math.max(key.length * 8 + 60, 120);
        return `${Math.min(estimatedWidth, this.maxColumnWidth)}px`;
    }
  }

  formatCellValue(row: any, column: TableColumn): string {
    const value = this.getNestedValue(row, column.key);

    if (value === null || value === undefined) {
      return '';
    }

    switch (column.type) {
      case 'boolean':
        return value ? 'Yes' : 'No';
      
      case 'number':
        return typeof value === 'number' ? this.formatNumber(value) : String(value);
      
      case 'date':
        return this.formatDate(value);
      
      case 'array':
        return this.formatArrayValue(value);
      
      case 'object':
      case 'nested':
        return this.formatObjectValue(value);
      
      default:
        return this.truncateText(String(value), 50);
    }
  }

  private formatArrayValue(value: any): string {
    if (!Array.isArray(value)) return String(value);
    
    switch (this.arrayDisplayMode) {
      case 'count':
        return `${value.length} item${value.length !== 1 ? 's' : ''}`;
      
      case 'preview':
        if (value.length === 0) return 'Empty array';
        const preview = value.slice(0, 2).map(item => {
          if (typeof item === 'object') return '{...}';
          return String(item);
        }).join(', ');
        return value.length > 2 ? `${preview}, +${value.length - 2} more` : preview;
      
      case 'expanded':
        return `[${value.map(item => typeof item === 'object' ? '{...}' : String(item)).join(', ')}]`;
      
      default:
        return `${value.length} items`;
    }
  }

  private formatObjectValue(value: any): string {
    if (typeof value !== 'object' || value === null) return String(value);
    
    const keys = Object.keys(value);
    if (keys.length === 0) return 'Empty object';
    
    const preview = keys.slice(0, 2).join(', ');
    return keys.length > 2 ? `{${preview}, +${keys.length - 2} more}` : `{${preview}}`;
  }

  private formatNumber(value: number): string {
    if (Number.isInteger(value)) {
      return value.toLocaleString();
    }
    return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  private formatDate(value: any): string {
    try {
      const date = new Date(value);
      if (isNaN(date.getTime())) return String(value);
      
      return new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }).format(date);
    } catch {
      return String(value);
    }
  }

  getNestedValue(obj: any, path: string): any {
    if (!obj) return null;
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  private truncateText(text: string, maxLength: number): string {
    if (!text) return '';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  }

  private createFilter(): (data: any, filter: string) => boolean {
    return (data: any, filter: string): boolean => {
      if (!filter) return true;
      
      const searchStr = filter.toLowerCase();
      
      // Search in flattened data for nested content
      const searchData = this.flattenNestedObjects ? data : JsonContentComponent.flattenObject(data, '', 2);
      
      return Object.values(searchData).some(value => {
        if (value === null || value === undefined) return false;
        const stringValue = String(value).toLowerCase();
        return stringValue.includes(searchStr);
      });
    };
  }

  onSearch(): void {
    const filterValue = this.searchQuery.trim().toLowerCase();
    this.dataSource.filter = filterValue;
    this.filteredRecords = this.dataSource.filteredData.length;
    
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
    
    this.cdr.markForCheck();
  }

  clearSearch(): void {
    this.searchQuery = '';
    this.dataSource.filter = '';
    this.filteredRecords = this.totalRecords;
    this.cdr.markForCheck();
  }

  exportToCSV(): void {
    if (!this._parsedJsonData?.length) return;

    const dataToExport = this.flattenNestedObjects ? this._flattenedData : this.dataSource.filteredData || this._parsedJsonData;
    const csvData = this.convertToCSV(dataToExport);
    this.downloadCSV(csvData);
  }

  private convertToCSV(data: any[]): string {
    if (!data?.length) return '';

    const headers = this.columns.map(col => col.label);
    const csvHeaders = headers.join(',');
    
    const csvRows = data.map(row => {
      return this.columns.map(col => {
        const value = this.getNestedValue(row, col.key);
        let formattedValue = '';
        
        if (value !== null && value !== undefined) {
          if (col.type === 'object' || col.type === 'array' || col.type === 'nested') {
            formattedValue = JSON.stringify(value);
          } else {
            formattedValue = String(value);
          }
        }
        
        if (formattedValue.includes(',') || formattedValue.includes('"') || formattedValue.includes('\n')) {
          formattedValue = `"${formattedValue.replace(/"/g, '""')}"`;
        }
        
        return formattedValue;
      }).join(',');
    });

    return [csvHeaders, ...csvRows].join('\n');
  }

  private downloadCSV(csvData: string): void {
    const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `json-data-export-${new Date().getTime()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  }

  getTypeIcon(type: string): string {
    const icons = {
      'string': 'abc',
      'number': 'tag',
      'boolean': 'check_box',
      'date': 'schedule',
      'object': 'data_object',
      'array': 'view_list',
      'nested': 'account_tree'
    };
    return icons[type as keyof typeof icons] || 'help';
  }

  getCellClass(column: TableColumn): string {
    return `cell cell--${column.type}`;
  }

  getBooleanIcon(value: any): string {
    return value ? 'check_circle' : 'cancel';
  }

  getBooleanClass(value: any): string {
    return value ? 'boolean-true' : 'boolean-false';
  }

  onCellClick(row: any, column: TableColumn): void {
    if (column.type === 'object' || column.type === 'array' || column.type === 'nested') {
      const value = this.getNestedValue(row, column.key);
      if (value) {
        console.log(`${column.label} details:`, value);
        this.showDetailedView(value, column.label);
      }
    }
  }

  private showDetailedView(data: any, title: string): void {
    // You can implement a proper modal component here
    const formattedJson = JSON.stringify(data, null, 2);
    alert(`${title}:\n${formattedJson}`);
  }

  // New methods for nested functionality
  toggleRowExpansion(index: number): void {
    if (this.expandedRows.has(index)) {
      this.expandedRows.delete(index);
    } else {
      this.expandedRows.add(index);
    }
    this.cdr.markForCheck();
  }

  isRowExpanded(index: number): boolean {
    return this.expandedRows.has(index);
  }

  toggleFlattenMode(): void {
    this.flattenNestedObjects = !this.flattenNestedObjects;
    this.applyStartIndexAndInitialize();
  }

  changeArrayDisplayMode(mode: 'preview' | 'count' | 'expanded'): void {
    this.arrayDisplayMode = mode;
    this.cdr.markForCheck();
  }

  getArrayPreview(value: any, maxItems: number = 3): string[] {
    if (!Array.isArray(value)) return [];
    
    return value.slice(0, maxItems).map(item => {
      if (typeof item === 'object') {
        return JSON.stringify(item);
      }
      return String(item);
    });
  }

  getObjectKeys(value: any): string[] {
    if (!value || typeof value !== 'object') return [];
    return Object.keys(value);
  }

  trackByColumn(index: number, column: TableColumn): string {
    return column.key;
  }

  trackByRow(index: number, row: any): any {
    return row?.id || row?.key || index;
  }

  private resetTable(): void {
    this.columns = [];
    this.displayedColumns = [];
    this.dataSource.data = [];
    this.totalRecords = 0;
    this.filteredRecords = 0;
    this.searchQuery = '';
    this.expandedRows.clear();
  }

  hasData(): boolean {
    return !!(this._parsedJsonData && this._parsedJsonData.length > 0);
  }

  getColumnStats(column: TableColumn): string {
    if (!this.hasData()) return '';
    
    const currentData = this.flattenNestedObjects ? this._flattenedData : this._displayedData;
    const values = currentData
      .map(row => this.getNestedValue(row, column.key))
      .filter(val => val !== null && val !== undefined);
    
    if (values.length === 0) return 'No data';
    
    switch (column.type) {
      case 'number':
        const numValues = values.filter(v => typeof v === 'number');
        if (numValues.length > 0) {
          const avg = numValues.reduce((a, b) => a + b, 0) / numValues.length;
          return `Avg: ${avg.toFixed(2)}`;
        }
        break;
      case 'boolean':
        const trueCount = values.filter(v => v === true).length;
        return `${trueCount}/${values.length} true`;
      case 'string':
        const uniqueCount = new Set(values).size;
        return `${uniqueCount} unique`;
      case 'array':
        const avgLength = values.reduce((sum, arr) => {
          return sum + (Array.isArray(arr) ? arr.length : 0);
        }, 0) / values.length;
        return `Avg: ${avgLength.toFixed(1)} items`;
      case 'object':
      case 'nested':
        const avgProps = values.reduce((sum, obj) => {
          return sum + (typeof obj === 'object' ? Object.keys(obj).length : 0);
        }, 0) / values.length;
        return `Avg: ${avgProps.toFixed(1)} props`;
      case 'date':
        return `${values.length} dates`;
    }
    
    return `${values.length} values`;
  }

  getBooleanValue(row: any, column: TableColumn): boolean {
    return !!this.getNestedValue(row, column.key);
  }

  hasObjectData(row: any, column: TableColumn): boolean {
    const value = this.getNestedValue(row, column.key);
    return value && typeof value === 'object' && Object.keys(value).length > 0;
  }

  getArrayLength(row: any, column: TableColumn): number {
    const value = this.getNestedValue(row, column.key);
    return Array.isArray(value) ? value.length : 0;
  }

  refreshTable(): void {
    this.initializeTable();
  }

  // New method to get nested path information
  getNestedPath(key: string): string[] {
    return key.split('.');
  }

  // Method to check if a field is deeply nested
  isDeepNested(key: string): boolean {
    return key.includes('.') && key.split('.').length > 2;
  }
}


<div class="json-content-wrapper">
  <!-- Header Controls Section -->
  <div class="table-controls" *ngIf="enableSearch || enableExport">
    <div class="controls-left">
      <!-- Search Input -->
      <mat-form-field class="search-input" appearance="outline" *ngIf="enableSearch">
        <mat-label>Search in table</mat-label>
        <input matInput 
               [(ngModel)]="searchQuery" 
               (input)="onSearch()" 
               placeholder="Type to filter records..."
               autocomplete="off">
        <mat-icon matSuffix class="search-icon">search</mat-icon>
        <button mat-icon-button 
                matSuffix 
                *ngIf="searchQuery" 
                (click)="clearSearch()" 
                matTooltip="Clear search">
          <mat-icon>close</mat-icon>
        </button>
      </mat-form-field>
    </div>
    
    <!-- View Controls -->
    <div class="view-controls">
      <!-- Flatten Toggle -->
      <button mat-stroked-button 
              [color]="flattenNestedObjects ? 'accent' : 'primary'"
              (click)="toggleFlattenMode()"
              matTooltip="Toggle between nested and flattened view">
        <mat-icon>{{ flattenNestedObjects ? 'unfold_less' : 'unfold_more' }}</mat-icon>
        {{ flattenNestedObjects ? 'Nested' : 'Flatten' }}
      </button>

      <!-- Array Display Mode -->
      <mat-form-field appearance="outline" class="array-mode-select">
        <mat-label>Array Display</mat-label>
        <select matNativeControl [(ngModel)]="arrayDisplayMode" (change)="changeArrayDisplayMode(arrayDisplayMode)">
          <option value="preview">Preview</option>
          <option value="count">Count Only</option>
          <option value="expanded">Expanded</option>
        </select>
      </mat-form-field>
    </div>
    
    <div class="controls-right">
      <!-- Record Counter -->
      <div class="record-counter">
        <mat-icon class="counter-icon">table_rows</mat-icon>
        <span class="counter-text">
          <strong>{{ filteredRecords }}</strong>
          <span *ngIf="filteredRecords !== totalRecords"> of {{ totalRecords }}</span>
          records
        </span>
      </div>
      
      <!-- Export Button -->
      <button mat-raised-button 
              color="primary"
              *ngIf="enableExport" 
              (click)="exportToCSV()"
              [disabled]="!hasData()"
              matTooltip="Export to CSV">
        <mat-icon>file_download</mat-icon>
        Export
      </button>
    </div>
  </div>

  <!-- Loading State -->
  <div class="loading-state" *ngIf="isLoading">
    <mat-spinner diameter="48" color="primary"></mat-spinner>
    <p class="loading-message">Processing JSON data...</p>
  </div>

  <!-- Empty State -->
  <div class="empty-state" *ngIf="!isLoading && !hasData()">
    <mat-icon class="empty-icon">table_chart</mat-icon>
    <h2 class="empty-title">No Data Available</h2>
    <p class="empty-description">
      Please provide JSON data to display in the table.
    </p>
  </div>

  <!-- Main Data Table -->
  <div class="table-container" *ngIf="!isLoading && hasData()">
    <table mat-table 
           [dataSource]="dataSource" 
           matSort 
           class="data-table">
      
      <!-- Dynamic Column Generation -->
      <ng-container *ngFor="let column of columns; trackBy: trackByColumn" 
                    [matColumnDef]="column.key">
        
        <!-- Header Cell -->
        <th mat-header-cell 
            *matHeaderCellDef 
            [mat-sort-header]="column.sortable ? column.key : ''"
            [disabled]="!column.sortable"
            class="header-cell"
            [ngClass]="'header-' + column.type"
            [style.width]="column.width">
          
          <div class="header-content">
            <div class="header-main">
              <mat-icon class="type-indicator" 
                        [matTooltip]="'Type: ' + column.type + (column.maxDepth ? ' (Depth: ' + column.maxDepth + ')' : '')">
                {{ getTypeIcon(column.type) }}
              </mat-icon>
              <span class="column-title" [matTooltip]="column.key">{{ column.label }}</span>
              
              <!-- Nested indicator -->
              <mat-icon *ngIf="column.type === 'nested' || column.nestedColumns?.length" 
                        class="nested-indicator"
                        matTooltip="Contains nested data">
                account_tree
              </mat-icon>
              
              <!-- Deep nesting indicator -->
              <mat-chip *ngIf="isDeepNested(column.key)" 
                        class="depth-chip"
                        [matTooltip]="'Nested path: ' + column.key">
                Deep
              </mat-chip>
            </div>
            <div class="header-stats" *ngIf="showSchemaPanel">
              <small class="stats-text">{{ getColumnStats(column) }}</small>
            </div>
          </div>
        </th>
        
        <!-- Data Cells -->
        <td mat-cell 
            *matCellDef="let row; let i = index" 
            [ngClass]="getCellClass(column)"
            [style.width]="column.width"
            (click)="onCellClick(row, column)">
          
          <!-- String Type Display -->
          <span *ngIf="column.type === 'string'" 
                class="cell-content text-content">
            {{ formatCellValue(row, column) }}
          </span>
          
          <!-- Number Type Display -->
          <span *ngIf="column.type === 'number'" 
                class="cell-content number-content">
            {{ formatCellValue(row, column) }}
          </span>
          
          <!-- Boolean Type Display -->
          <div *ngIf="column.type === 'boolean'" 
               class="cell-content boolean-content">
            <mat-icon [ngClass]="getBooleanClass(getBooleanValue(row, column))">
              {{ getBooleanIcon(getBooleanValue(row, column)) }}
            </mat-icon>
            <span class="boolean-text">{{ formatCellValue(row, column) }}</span>
          </div>
          
          <!-- Date Type Display -->
          <span *ngIf="column.type === 'date'" 
                class="cell-content date-content">
            {{ formatCellValue(row, column) }}
          </span>
          
          <!-- Array Type Display -->
          <div *ngIf="column.type === 'array'" 
               class="cell-content array-content">
            <div class="array-display">
              <!-- Array preview chips -->
              <div class="array-chips" *ngIf="arrayDisplayMode === 'preview'">
                <mat-chip *ngFor="let item of getArrayPreview(getNestedValue(row, column.key), 2); let idx = index"
                          class="array-item-chip"
                          [matTooltip]="'Array item ' + idx">
                  {{ item.length > 20 ? item.substring(0, 20) + '...' : item }}
                </mat-chip>
                <mat-chip *ngIf="getArrayLength(row, column) > 2" 
                          class="array-more-chip">
                  +{{ getArrayLength(row, column) - 2 }} more
                </mat-chip>
              </div>
              
              <!-- Array count display -->
              <div class="array-count" *ngIf="arrayDisplayMode === 'count'">
                <mat-icon class="array-icon">view_list</mat-icon>
                <span class="array-text">{{ formatCellValue(row, column) }}</span>
              </div>
              
              <!-- Expanded array display -->
              <div class="array-expanded" *ngIf="arrayDisplayMode === 'expanded'">
                <button mat-stroked-button 
                        class="array-toggle"
                        (click)="toggleRowExpansion(i); $event.stopPropagation()"
                        [matTooltip]="'Click to ' + (isRowExpanded(i) ? 'collapse' : 'expand') + ' array details'">
                  <mat-icon>{{ isRowExpanded(i) ? 'expand_less' : 'expand_more' }}</mat-icon>
                  {{ getArrayLength(row, column) }} items
                </button>
              </div>
            </div>
            
            <!-- Expanded Array Content -->
            <div class="expanded-array-content" 
                 *ngIf="isRowExpanded(i) && arrayDisplayMode === 'expanded'">
              <div class="array-items">
                <div *ngFor="let item of getNestedValue(row, column.key); let idx = index; trackBy: trackByRow"
                     class="array-item">
                  <span class="item-index">[{{ idx }}]</span>
                  <span class="item-value">
                    {{ typeof item === 'object' ? (item | json) : item }}
                  </span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Object Type Display -->
          <div *ngIf="column.type === 'object'" 
               class="cell-content object-content">
            <button mat-stroked-button 
                    class="object-button"
                    [disabled]="!hasObjectData(row, column)"
                    [matTooltip]="hasObjectData(row, column) ? 'Click to view object details' : 'No object data'">
              <mat-icon>data_object</mat-icon>
              <span>{{ formatCellValue(row, column) }}</span>
            </button>
          </div>
          
          <!-- Nested Type Display -->
          <div *ngIf="column.type === 'nested'" 
               class="cell-content nested-content">
            <div class="nested-display">
              <button mat-stroked-button 
                      class="nested-toggle"
                      (click)="toggleRowExpansion(i); $event.stopPropagation()"
                      [matTooltip]="'Click to ' + (isRowExpanded(i) ? 'collapse' : 'expand') + ' nested data'">
                <mat-icon>{{ isRowExpanded(i) ? 'expand_less' : 'expand_more' }}</mat-icon>
                <span>{{ formatCellValue(row, column) }}</span>
                <mat-icon class="nested-icon">account_tree</mat-icon>
              </button>
            </div>
            
            <!-- Expanded Nested Content -->
            <div class="expanded-nested-content" *ngIf="isRowExpanded(i)">
              <mat-card class="nested-card">
                <mat-card-header>
                  <mat-card-title>{{ column.label }} Details</mat-card-title>
                </mat-card-header>
                <mat-card-content>
                  <div class="nested-properties">
                    <div *ngFor="let key of getObjectKeys(getNestedValue(row, column.key))"
                         class="nested-property">
                      <span class="property-key">{{ key }}:</span>
                      <span class="property-value">
                        {{ getNestedValue(getNestedValue(row, column.key), key) | json }}
                      </span>
                    </div>
                  </div>
                </mat-card-content>
              </mat-card>
            </div>
          </div>
        </td>
      </ng-container>

      <!-- Table Structure -->
      <tr mat-header-row 
          *matHeaderRowDef="displayedColumns; sticky: true" 
          class="table-header-row"></tr>
      <tr mat-row 
          *matRowDef="let row; columns: displayedColumns; let i = index" 
          class="table-data-row"
          [ngClass]="{'expanded-row': isRowExpanded(i)}"></tr>
    </table>
  </div>

  <!-- Pagination -->
  <mat-paginator *ngIf="!isLoading && hasData()"
                 #paginator
                 [pageSizeOptions]="pageSizeOptions"
                 [pageSize]="pageSize"
                 [showFirstLastButtons]="true"
                 [length]="filteredRecords"
                 class="table-paginator"
                 aria-label="Select page of JSON data">
  </mat-paginator>

  <!-- Schema Information Panel -->
  <mat-expansion-panel class="schema-panel" 
                       *ngIf="showSchemaPanel && columns.length > 0"
                       [expanded]="false">
    <mat-expansion-panel-header>
      <mat-panel-title>
        <mat-icon class="panel-icon">analytics</mat-icon>
        <span>Schema Information</span>
      </mat-panel-title>
      <mat-panel-description>
        {{ flattenNestedObjects ? 'Flattened view' : 'Nested view' }} • {{ columns.length }} fields
      </mat-panel-description>
    </mat-expansion-panel-header>
    
    <div class="schema-content">
      <!-- Schema Description -->
      <div class="schema-info-header">
        <p class="schema-description">
          Schema automatically generated from the first JSON record. 
          {{ flattenNestedObjects ? 'Nested objects have been flattened into dot-notation columns.' : 'Nested objects are displayed with expandable controls.' }}
        </p>
        <div class="schema-summary">
          <span class="summary-item">
            <mat-icon>storage</mat-icon>
            Total Records: <strong>{{ totalRecords }}</strong>
          </span>
          <span class="summary-item">
            <mat-icon>view_column</mat-icon>
            Columns: <strong>{{ columns.length }}</strong>
          </span>
          <span class="summary-item">
            <mat-icon>account_tree</mat-icon>
            Mode: <strong>{{ flattenNestedObjects ? 'Flattened' : 'Nested' }}</strong>
          </span>
        </div>
      </div>
      
      <!-- Schema Fields Grid -->
      <div class="schema-fields">
        <h4>Detected Fields:</h4>
        <div class="field-grid">
          <div *ngFor="let column of columns; trackBy: trackByColumn" 
               class="field-item"
               [ngClass]="'field-type-' + column.type">
            <div class="field-details">
              <!-- Field Header with Icon and Type -->
              <div class="field-header">
                <mat-icon class="field-icon" 
                          [matTooltip]="'Data type: ' + column.type">
                  {{ getTypeIcon(column.type) }}
                </mat-icon>
                <span class="field-name" 
                      [matTooltip]="'Original key: ' + column.key">
                  {{ column.key }}
                </span>
                <span class="field-type-chip" 
                      [ngClass]="'chip-' + column.type">
                  {{ column.type }}
                </span>
              </div>
              
              <!-- Field Path Information -->
              <div class="field-path" *ngIf="isDeepNested(column.key)">
                <mat-icon class="path-icon">timeline</mat-icon>
                <span class="path-text">
                  Path: <code>{{ column.key }}</code>
                </span>
              </div>
              
              <!-- Field Metadata -->
              <div class="field-meta">
                <span class="field-label">{{ column.label }}</span>
                <div class="field-properties">
                  <span class="field-sortable" *ngIf="column.sortable">
                    <mat-icon class="sortable-icon">sort</mat-icon>
                    Sortable
                  </span>
                  <span class="field-width">
                    Width: {{ column.width }}
                  </span>
                  <span class="field-depth" *ngIf="column.maxDepth">
                    <mat-icon class="depth-icon">layers</mat-icon>
                    Depth: {{ column.maxDepth }}
                  </span>
                </div>
              </div>
              
              <!-- Nested Columns Preview -->
              <div class="nested-columns-preview" *ngIf="column.nestedColumns?.length">
                <h5>Nested Fields ({{ column.nestedColumns.length }}):</h5>
                <div class="nested-chips">
                  <mat-chip *ngFor="let nestedCol of column.nestedColumns.slice(0, 3)"
                            class="nested-chip">
                    <mat-icon>{{ getTypeIcon(nestedCol.type) }}</mat-icon>
                    {{ nestedCol.key }}
                  </mat-chip>
                  <mat-chip *ngIf="column.nestedColumns.length > 3"
                            class="nested-more-chip">
                    +{{ column.nestedColumns.length - 3 }} more
                  </mat-chip>
                </div>
              </div>
              
              <!-- Field Statistics -->
              <div class="field-stats">
                <small>{{ getColumnStats(column) }}</small>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Schema Actions -->
      <div class="schema-actions">
        <button mat-button 
                color="primary" 
                (click)="exportToCSV()" 
                [disabled]="!hasData()"
                matTooltip="Export all data with schema information">
          <mat-icon>download</mat-icon>
          Export Schema + Data
        </button>
        <button mat-button 
                (click)="toggleFlattenMode()"
                [matTooltip]="'Switch to ' + (flattenNestedObjects ? 'nested' : 'flattened') + ' view'">
          <mat-icon>{{ flattenNestedObjects ? 'unfold_more' : 'unfold_less' }}</mat-icon>
          {{ flattenNestedObjects ? 'Show Nested' : 'Flatten View' }}
        </button>
        <button mat-button 
                (click)="refreshTable()"
                matTooltip="Refresh table and regenerate schema">
          <mat-icon>refresh</mat-icon>
          Refresh Table
        </button>
      </div>
    </div>
  </mat-expansion-panel>

  <!-- Footer Information -->
  <div class="table-footer" *ngIf="!isLoading && hasData()">
    <div class="footer-stats">
      <span class="stat-item">
        <mat-icon class="stat-icon">storage</mat-icon>
        {{ totalRecords }} total records
      </span>
      <span class="stat-item" *ngIf="filteredRecords !== totalRecords">
        <mat-icon class="stat-icon">filter_list</mat-icon>
        {{ filteredRecords }} filtered
      </span>
      <span class="stat-item">
        <mat-icon class="stat-icon">view_column</mat-icon>
        {{ columns.length }} columns
      </span>
      <span class="stat-item" *ngIf="searchQuery">
        <mat-icon class="stat-icon">search</mat-icon>
        Search: "{{ searchQuery }}"
      </span>
      <span class="stat-item">
        <mat-icon class="stat-icon">{{ flattenNestedObjects ? 'unfold_less' : 'account_tree' }}</mat-icon>
        {{ flattenNestedObjects ? 'Flattened' : 'Nested' }} View
      </span>
      <span class="stat-item">
        <mat-icon class="stat-icon">view_list</mat-icon>
        Arrays: {{ arrayDisplayMode }}
      </span>
    </div>
    
    <div class="footer-actions">
      <button mat-icon-button 
              (click)="refreshTable()"
              matTooltip="Refresh table data">
        <mat-icon>refresh</mat-icon>
      </button>
      <button mat-icon-button 
              (click)="clearSearch()"
              *ngIf="searchQuery"
              matTooltip="Clear search filter">
        <mat-icon>clear</mat-icon>
      </button>
      <button mat-icon-button 
              (click)="toggleFlattenMode()"
              [matTooltip]="'Toggle between nested and flattened view'">
        <mat-icon>{{ flattenNestedObjects ? 'unfold_more' : 'unfold_less' }}</mat-icon>
      </button>
    </div>
  </div>
</div>

// ==========================================
// DESIGN SYSTEM VARIABLES
// ==========================================

// Color Palette
$primary-blue: #1976d2;
$primary-blue-light: #42a5f5;
$primary-blue-dark: #0d47a1;
$accent-cyan: #00bcd4;
$accent-cyan-light: #4dd0e1;

// Status Colors
$success-green: #4caf50;
$warning-orange: #ff9800;
$error-red: #f44336;
$info-blue: #2196f3;
$nested-purple: #9c27b0;
$array-teal: #009688;

// Neutral Colors
$white: #ffffff;
$gray-50: #fafafa;
$gray-100: #f5f5f5;
$gray-200: #eeeeee;
$gray-300: #e0e0e0;
$gray-400: #bdbdbd;
$gray-500: #9e9e9e;
$gray-600: #757575;
$gray-700: #616161;
$gray-800: #424242;
$gray-900: #212121;

// Semantic Colors
$text-primary: $gray-900;
$text-secondary: $gray-600;
$text-disabled: $gray-400;
$text-hint: $gray-500;

$background-primary: $white;
$background-secondary: $gray-50;
$background-hover: rgba($primary-blue, 0.04);
$background-expanded: rgba($primary-blue, 0.02);

$border-light: $gray-200;
$border-medium: $gray-300;
$border-dark: $gray-400;

// Shadows
$shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.05);
$shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
$shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
$shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);

// Border Radius
$radius-sm: 4px;
$radius-md: 6px;
$radius-lg: 8px;
$radius-xl: 12px;

// Spacing
$spacing-xs: 4px;
$spacing-sm: 8px;
$spacing-md: 12px;
$spacing-lg: 16px;
$spacing-xl: 20px;
$spacing-2xl: 24px;
$spacing-3xl: 32px;

// Typography
$font-size-xs: 10px;
$font-size-sm: 12px;
$font-size-md: 14px;
$font-size-lg: 16px;
$font-size-xl: 18px;
$font-size-2xl: 20px;

$font-weight-normal: 400;
$font-weight-medium: 500;
$font-weight-semibold: 600;
$font-weight-bold: 700;

// ==========================================
// MIXINS
// ==========================================

@mixin flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

@mixin flex-between {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

@mixin flex-start {
  display: flex;
  align-items: center;
  justify-content: flex-start;
}

@mixin text-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

@mixin smooth-transition($properties: all, $duration: 0.3s, $easing: ease-in-out) {
  transition: $properties $duration $easing;
}

@mixin hover-lift {
  @include smooth-transition(transform, 0.2s);
  
  &:hover {
    transform: translateY(-1px);
  }
}

@mixin card-style($padding: $spacing-lg) {
  background: $background-primary;
  border-radius: $radius-lg;
  box-shadow: $shadow-md;
  padding: $padding;
}

@mixin nested-indent($level: 1) {
  padding-left: #{$spacing-lg * $level};
  border-left: 2px solid rgba($primary-blue, 0.2);
}

// ==========================================
// MAIN COMPONENT WRAPPER
// ==========================================

.json-content-wrapper {
  display: flex;
  flex-direction: column;
  width: 100%;
  font-family: 'Roboto', 'Helvetica Neue', Arial, sans-serif;
  background: $background-primary;
  border-radius: $radius-lg;
  box-shadow: $shadow-lg;
  overflow: hidden;

  // ==========================================
  // TABLE CONTROLS SECTION
  // ==========================================

  .table-controls {
    @include flex-between;
    padding: $spacing-2xl;
    background: linear-gradient(135deg, $gray-50 0%, $gray-100 100%);
    border-bottom: 1px solid $border-light;
    gap: $spacing-xl;
    flex-wrap: wrap;

    @media (max-width: 768px) {
      flex-direction: column;
      align-items: stretch;
      gap: $spacing-lg;
      padding: $spacing-lg;
    }

    .controls-left {
      flex: 1;
      min-width: 0;

      .search-input {
        width: 100%;
        max-width: 400px;

        ::ng-deep {
          .mat-mdc-form-field-wrapper {
            margin-bottom: 0;
          }

          .mat-mdc-form-field-flex {
            background-color: $white;
            border-radius: $radius-md;
          }

          .mat-mdc-form-field-outline {
            color: $border-medium;
          }

          .mat-mdc-form-field-focus-overlay {
            background-color: transparent;
          }
        }

        .search-icon {
          color: $text-secondary;
          font-size: 20px;
        }
      }
    }

    // ==========================================
    // NEW VIEW CONTROLS
    // ==========================================

    .view-controls {
      @include flex-start;
      gap: $spacing-lg;
      flex-wrap: wrap;

      @media (max-width: 768px) {
        width: 100%;
        justify-content: space-between;
      }

      .array-mode-select {
        min-width: 140px;

        ::ng-deep {
          .mat-mdc-form-field-wrapper {
            margin-bottom: 0;
          }

          .mat-mdc-form-field-flex {
            background-color: $white;
            border-radius: $radius-md;
          }
        }
      }

      button {
        @include flex-start;
        gap: $spacing-xs;
        font-size: $font-size-sm;
        font-weight: $font-weight-medium;
        
        .mat-icon {
          font-size: 18px;
        }
      }
    }

    .controls-right {
      @include flex-start;
      gap: $spacing-xl;

      @media (max-width: 768px) {
        justify-content: space-between;
        width: 100%;
      }

      .record-counter {
        @include flex-start;
        gap: $spacing-sm;
        color: $text-secondary;

        .counter-icon {
          font-size: 18px;
          color: $primary-blue;
        }

        .counter-text {
          font-size: $font-size-md;
          font-weight: $font-weight-medium;

          strong {
            color: $text-primary;
            font-weight: $font-weight-semibold;
          }
        }
      }
    }
  }

  // ==========================================
  // LOADING STATE
  // ==========================================

  .loading-state {
    @include flex-center;
    flex-direction: column;
    padding: $spacing-3xl * 2;
    gap: $spacing-2xl;

    .loading-message {
      color: $text-secondary;
      font-size: $font-size-lg;
      font-weight: $font-weight-medium;
      margin: 0;
    }
  }

  // ==========================================
  // EMPTY STATE
  // ==========================================

  .empty-state {
    @include flex-center;
    flex-direction: column;
    padding: $spacing-3xl * 2;
    text-align: center;

    .empty-icon {
      font-size: 72px;
      width: 72px;
      height: 72px;
      color: $gray-300;
      margin-bottom: $spacing-2xl;
    }

    .empty-title {
      font-size: $font-size-2xl;
      font-weight: $font-weight-semibold;
      color: $text-primary;
      margin: 0 0 $spacing-md 0;
    }

    .empty-description {
      font-size: $font-size-lg;
      color: $text-secondary;
      margin: 0;
      max-width: 400px;
      line-height: 1.5;
    }
  }

  // ==========================================
  // TABLE CONTAINER
  // ==========================================

  .table-container {
    overflow: auto;
    max-height: 70vh;
    border-bottom: 1px solid $border-light;

    // Custom scrollbar
    scrollbar-width: thin;
    scrollbar-color: $primary-blue-light transparent;

    &::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    &::-webkit-scrollbar-track {
      background: transparent;
    }

    &::-webkit-scrollbar-thumb {
      background-color: $primary-blue-light;
      border-radius: 3px;

      &:hover {
        background-color: $primary-blue;
      }
    }

    .data-table {
      width: 100%;
      background: $background-primary;

      // ==========================================
      // TABLE HEADER STYLES
      // ==========================================

      .table-header-row {
        background: linear-gradient(135deg, $gray-50 0%, $white 100%);
        position: sticky;
        top: 0;
        z-index: 100;

        .header-cell {
          font-weight: $font-weight-semibold;
          color: $text-primary;
          border-bottom: 2px solid $primary-blue;
          padding: $spacing-lg $spacing-md;
          position: relative;
          background: inherit;

          .header-content {
            display: flex;
            flex-direction: column;
            gap: $spacing-xs;

            .header-main {
              @include flex-start;
              gap: $spacing-sm;

              .type-indicator {
                font-size: 16px;
                opacity: 0.7;
                @include smooth-transition(opacity);

                &:hover {
                  opacity: 1;
                }
              }

              .column-title {
                @include text-truncate;
                flex: 1;
                font-weight: $font-weight-semibold;
              }

              // ==========================================
              // NEW NESTED INDICATORS
              // ==========================================

              .nested-indicator {
                font-size: 14px;
                color: $nested-purple;
                opacity: 0.8;
              }

              .depth-chip {
                background-color: rgba($nested-purple, 0.1);
                color: $nested-purple;
                font-size: $font-size-xs;
                height: 20px;
                font-weight: $font-weight-medium;
                
                ::ng-deep .mat-mdc-chip-label {
                  font-size: $font-size-xs;
                  padding: 0 $spacing-xs;
                }
              }
            }

            .header-stats {
              .stats-text {
                font-size: $font-size-xs;
                color: $text-hint;
                font-weight: $font-weight-normal;
              }
            }
          }

          // Type-specific header styles
          &.header-string .type-indicator { color: $primary-blue; }
          &.header-number .type-indicator { color: $success-green; }
          &.header-boolean .type-indicator { color: $warning-orange; }
          &.header-date .type-indicator { color: #9c27b0; }
          &.header-object .type-indicator { color: #795548; }
          &.header-array .type-indicator { color: $array-teal; }
          &.header-nested .type-indicator { color: $nested-purple; }
        }
      }

      // ==========================================
      // TABLE ROW STYLES
      // ==========================================

      .table-data-row {
        @include smooth-transition(background-color);

        &:hover {
          background-color: $background-hover;
        }

        &:nth-child(even) {
          background-color: rgba($gray-50, 0.5);
        }

        // ==========================================
        // EXPANDED ROW STYLES
        // ==========================================

        &.expanded-row {
          background-color: $background-expanded;
          
          .cell {
            border-bottom: 1px solid rgba($primary-blue, 0.2);
          }
        }

        // ==========================================
        // CELL STYLES
        // ==========================================

        .cell {
          padding: $spacing-md;
          border-bottom: 1px solid $border-light;
          @include smooth-transition(all);
          vertical-align: top;

          .cell-content {
            display: flex;
            align-items: flex-start;
            flex-direction: column;
            gap: $spacing-xs;
            min-height: 20px;
          }

          // String cells
          &.cell--string {
            .text-content {
              @include text-truncate;
              color: $text-primary;
              width: 100%;
            }
          }

          // Number cells
          &.cell--number {
            .number-content {
              font-weight: $font-weight-medium;
              color: $success-green;
              text-align: right;
              font-variant-numeric: tabular-nums;
              width: 100%;
            }
          }

          // Boolean cells
          &.cell--boolean {
            .boolean-content {
              @include flex-start;
              gap: $spacing-sm;

              .mat-icon {
                font-size: 20px;
                width: 20px;
                height: 20px;

                &.boolean-true {
                  color: $success-green;
                }

                &.boolean-false {
                  color: $error-red;
                }
              }

              .boolean-text {
                font-size: $font-size-sm;
                font-weight: $font-weight-medium;
              }
            }
          }

          // Date cells
          &.cell--date {
            .date-content {
              font-family: 'Roboto Mono', 'Courier New', monospace;
              font-size: $font-size-sm;
              color: #9c27b0;
              font-weight: $font-weight-medium;
            }
          }

          // ==========================================
          // ENHANCED ARRAY CELLS
          // ==========================================

          &.cell--array {
            .array-content {
              .array-display {
                width: 100%;

                .array-chips {
                  @include flex-start;
                  gap: $spacing-xs;
                  flex-wrap: wrap;

                  .array-item-chip {
                    background-color: rgba($array-teal, 0.1);
                    color: $array-teal;
                    font-size: $font-size-xs;
                    height: 24px;
                    max-width: 120px;

                    ::ng-deep .mat-mdc-chip-label {
                      @include text-truncate;
                      font-size: $font-size-xs;
                      padding: 0 $spacing-xs;
                    }
                  }

                  .array-more-chip {
                    background-color: rgba($gray-500, 0.1);
                    color: $gray-600;
                    font-size: $font-size-xs;
                    height: 24px;

                    ::ng-deep .mat-mdc-chip-label {
                      font-size: $font-size-xs;
                      padding: 0 $spacing-xs;
                    }
                  }
                }

                .array-count {
                  @include flex-start;
                  gap: $spacing-sm;

                  .array-icon {
                    font-size: 18px;
                    color: $array-teal;
                  }

                  .array-text {
                    font-size: $font-size-sm;
                    font-weight: $font-weight-medium;
                    color: $array-teal;
                  }
                }

                .array-expanded {
                  .array-toggle {
                    @include flex-start;
                    gap: $spacing-xs;
                    font-size: $font-size-sm;
                    background-color: rgba($array-teal, 0.1);
                    color: $array-teal;
                    border: 1px solid rgba($array-teal, 0.3);
                    border-radius: $radius-sm;
                    @include smooth-transition(all);
                    @include hover-lift;

                    .mat-icon {
                      font-size: 16px;
                    }

                    &:hover {
                      background-color: rgba($array-teal, 0.2);
                      border-color: $array-teal;
                    }
                  }
                }
              }

              .expanded-array-content {
                margin-top: $spacing-md;
                @include card-style($spacing-md);
                border: 1px solid rgba($array-teal, 0.2);
                max-height: 200px;
                overflow-y: auto;

                .array-items {
                  .array-item {
                    @include flex-start;
                    gap: $spacing-sm;
                    padding: $spacing-xs 0;
                    border-bottom: 1px solid $border-light;

                    &:last-child {
                      border-bottom: none;
                    }

                    .item-index {
                      font-family: 'Roboto Mono', monospace;
                      font-size: $font-size-xs;
                      color: $text-secondary;
                      font-weight: $font-weight-medium;
                      min-width: 32px;
                    }

                    .item-value {
                      flex: 1;
                      font-size: $font-size-sm;
                      @include text-truncate;
                      font-family: 'Roboto Mono', monospace;
                    }
                  }
                }
              }
            }
          }

          // Object cells
          &.cell--object {
            .object-content {
              .object-button {
                @include flex-start;
                gap: $spacing-xs;
                padding: $spacing-xs $spacing-sm;
                min-height: 32px;
                font-size: $font-size-sm;
                background-color: rgba(#795548, 0.1);
                color: #795548;
                border: 1px solid rgba(#795548, 0.3);
                border-radius: $radius-sm;
                @include smooth-transition(all);
                @include hover-lift;

                .mat-icon {
                  font-size: 16px;
                  width: 16px;
                  height: 16px;
                }

                &:hover:not([disabled]) {
                  background-color: rgba(#795548, 0.2);
                  border-color: #795548;
                }

                &[disabled] {
                  opacity: 0.6;
                  cursor: not-allowed;
                  transform: none;
                }
              }
            }
          }

          // ==========================================
          // NEW NESTED CELLS
          // ==========================================

          &.cell--nested {
            .nested-content {
              .nested-display {
                width: 100%;

                .nested-toggle {
                  @include flex-start;
                  gap: $spacing-xs;
                  padding: $spacing-xs $spacing-sm;
                  font-size: $font-size-sm;
                  background-color: rgba($nested-purple, 0.1);
                  color: $nested-purple;
                  border: 1px solid rgba($nested-purple, 0.3);
                  border-radius: $radius-sm;
                  @include smooth-transition(all);
                  @include hover-lift;

                  .mat-icon {
                    font-size: 16px;
                  }

                  .nested-icon {
                    margin-left: auto;
                    opacity: 0.7;
                  }

                  &:hover {
                    background-color: rgba($nested-purple, 0.2);
                    border-color: $nested-purple;
                  }
                }
              }

              .expanded-nested-content {
                margin-top: $spacing-md;

                .nested-card {
                  border: 1px solid rgba($nested-purple, 0.2);
                  border-radius: $radius-md;
                  box-shadow: $shadow-sm;

                  ::ng-deep {
                    .mat-mdc-card-header {
                      padding: $spacing-md;
                      background-color: rgba($nested-purple, 0.05);

                      .mat-mdc-card-title {
                        font-size: $font-size-md;
                        font-weight: $font-weight-semibold;
                        color: $nested-purple;
                      }
                    }

                    .mat-mdc-card-content {
                      padding: $spacing-md;
                    }
                  }

                  .nested-properties {
                    .nested-property {
                      @include flex-start;
                      gap: $spacing-sm;
                      padding: $spacing-xs 0;
                      border-bottom: 1px solid $border-light;

                      &:last-child {
                        border-bottom: none;
                      }

                      .property-key {
                        font-weight: $font-weight-medium;
                        color: $text-primary;
                        min-width: 80px;
                        font-size: $font-size-sm;
                      }

                      .property-value {
                        flex: 1;
                        font-family: 'Roboto Mono', monospace;
                        font-size: $font-size-sm;
                        color: $text-secondary;
                        word-break: break-all;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // ==========================================
  // PAGINATION STYLES
  // ==========================================

  .table-paginator {
    background: $background-secondary;
    border-top: 1px solid $border-light;

    ::ng-deep {
      .mat-mdc-paginator-container {
        padding: $spacing-lg $spacing-2xl;
      }

      .mat-mdc-paginator-range-label {
        color: $text-secondary;
        font-weight: $font-weight-medium;
      }
    }
  }

  // ==========================================
  // ENHANCED SCHEMA PANEL STYLES
  // ==========================================

  .schema-panel {
    margin-top: $spacing-lg;
    border-radius: $radius-lg;
    box-shadow: $shadow-sm;

    ::ng-deep {
      .mat-expansion-panel-header {
        padding: $spacing-lg $spacing-2xl;

        .mat-panel-title {
          @include flex-start;
          gap: $spacing-sm;
          font-weight: $font-weight-semibold;

          .panel-icon {
            color: $primary-blue;
            font-size: 20px;
          }
        }

        .mat-panel-description {
          color: $text-secondary;
          font-size: $font-size-sm;
          margin-left: auto;
        }
      }

      .mat-expansion-panel-content {
        .mat-expansion-panel-body {
          padding: $spacing-2xl;
        }
      }
    }

    .schema-content {
      .schema-info-header {
        margin-bottom: $spacing-2xl;

        .schema-description {
          color: $text-secondary;
          font-size: $font-size-md;
          line-height: 1.5;
          margin: 0 0 $spacing-lg 0;
        }

        .schema-summary {
          @include flex-start;
          gap: $spacing-2xl;
          flex-wrap: wrap;

          .summary-item {
            @include flex-start;
            gap: $spacing-xs;
            color: $text-secondary;
            font-size: $font-size-sm;

            .mat-icon {
              font-size: 16px;
              color: $primary-blue;
            }

            strong {
              color: $text-primary;
              font-weight: $font-weight-semibold;
            }
          }
        }
      }

      .schema-fields {
        h4 {
          color: $text-primary;
          font-size: $font-size-lg;
          font-weight: $font-weight-semibold;
          margin: 0 0 $spacing-lg 0;
        }

        .field-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
          gap: $spacing-lg;

          @media (max-width: 768px) {
            grid-template-columns: 1fr;
          }

          .field-item {
            &.field-type-nested {
              .field-details {
                border-left: 4px solid $nested-purple;
              }
            }

            &.field-type-array {
              .field-details {
                border-left: 4px solid $array-teal;
              }
            }

            .field-details {
              @include card-style($spacing-md);
              border: 1px solid $border-light;
              @include smooth-transition(all);
              @include hover-lift;

              &:hover {
                border-color: $primary-blue;
                box-shadow: $shadow-md;
              }

              .field-header {
                @include flex-between;
                margin-bottom: $spacing-sm;

                .field-icon {
                  font-size: 18px;
                  color: $primary-blue;
                }

                .field-name {
                  flex: 1;
                  margin: 0 $spacing-sm;
                  font-weight: $font-weight-semibold;
                  color: $text-primary;
                  @include text-truncate;
                }

                .field-type-chip {
                  font-size: $font-size-xs;
                  font-weight: $font-weight-medium;
                  padding: $spacing-xs $spacing-sm;
                  border-radius: $radius-sm;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;

                  // Type-specific chip colors
                  &.chip-string { background-color: rgba($primary-blue, 0.1); color: $primary-blue; }
                  &.chip-number { background-color: rgba($success-green, 0.1); color: $success-green; }
                  &.chip-boolean { background-color: rgba($warning-orange, 0.1); color: $warning-orange; }
                  &.chip-date { background-color: rgba(#9c27b0, 0.1); color: #9c27b0; }
                  &.chip-object { background-color: rgba(#795548, 0.1); color: #795548; }
                  &.chip-array { background-color: rgba($array-teal, 0.1); color: $array-teal; }
                  &.chip-nested { background-color: rgba($nested-purple, 0.1); color: $nested-purple; }
                }
              }

              // ==========================================
              // NEW FIELD PATH INFORMATION
              // ==========================================

              .field-path {
                @include flex-start;
                gap: $spacing-xs;
                margin-bottom: $spacing-sm;
                padding: $spacing-xs;
                background-color: rgba($gray-100, 0.5);
                border-radius: $radius-sm;

                .path-icon {
                  font-size: 14px;
                  color: $text-hint;
                }

                .path-text {
                  font-size: $font-size-xs;
                  color: $text-hint;

                  code {
                    background-color: rgba($gray-200, 0.8);
                    padding: 2px $spacing-xs;
                    border-radius: 2px;
                    font-family: 'Roboto Mono', monospace;
                    font-size: $font-size-xs;
                  }
                }
              }

              .field-meta {
                margin-bottom: $spacing-sm;

                .field-label {
                  display: block;
                  font-size: $font-size-sm;
                  color: $text-secondary;
                  margin-bottom: $spacing-xs;
                }

                .field-properties {
                  @include flex-between;
                  gap: $spacing-sm;
                  flex-wrap: wrap;

                  .field-sortable {
                    @include flex-start;
                    gap: $spacing-xs;
                    font-size: $font-size-xs;
                    color: $success-green;
                    font-weight: $font-weight-medium;

                    .sortable-icon {
                      font-size: 14px;
                    }
                  }

                  .field-width {
                    font-size: $font-size-xs;
                    color: $text-hint;
                  }

                  .field-depth {
                    @include flex-start;
                    gap: $spacing-xs;
                    font-size: $font-size-xs;
                    color: $nested-purple;
                    font-weight: $font-weight-medium;

                    .depth-icon {
                      font-size: 14px;
                    }
                  }
                }
              }

              // ==========================================
              // NEW NESTED COLUMNS PREVIEW
              // ==========================================

              .nested-columns-preview {
                margin-bottom: $spacing-sm;
                padding: $spacing-sm;
                background-color: rgba($nested-purple, 0.05);
                border-radius: $radius-sm;
                border: 1px solid rgba($nested-purple, 0.1);

                h5 {
                  font-size: $font-size-sm;
                  font-weight: $font-weight-semibold;
                  color: $nested-purple;
                  margin: 0 0 $spacing-xs 0;
                }

                .nested-chips {
                  @include flex-start;
                  gap: $spacing-xs;
                  flex-wrap: wrap;

                  .nested-chip {
                    background-color: rgba($nested-purple, 0.1);
                    color: $nested-purple;
                    font-size: $font-size-xs;
                    height: 24px;

                    ::ng-deep .mat-mdc-chip-label {
                      @include flex-start;
                      gap: 2px;
                      font-size: $font-size-xs;
                      padding: 0 $spacing-xs;

                      .mat-icon {
                        font-size: 12px;
                        width: 12px;
                        height: 12px;
                      }
                    }
                  }

                  .nested-more-chip {
                    background-color: rgba($gray-500, 0.1);
                    color: $gray-600;
                    font-size: $font-size-xs;
                    height: 24px;

                    ::ng-deep .mat-mdc-chip-label {
                      font-size: $font-size-xs;
                      padding: 0 $spacing-xs;
                    }
                  }
                }
              }

              .field-stats {
                font-size: $font-size-xs;
                color: $text-hint;
                font-style: italic;
              }
            }
          }
        }
      }

      .schema-actions {
        @include flex-start;
        gap: $spacing-lg;
        margin-top: $spacing-2xl;
        padding-top: $spacing-lg;
        border-top: 1px solid $border-light;
        flex-wrap: wrap;

        button {
          @include flex-start;
          gap: $spacing-xs;
        }
      }
    }
  }

  // ==========================================
  // ENHANCED FOOTER STYLES
  // ==========================================

  .table-footer {
    @include flex-between;
    padding: $spacing-lg $spacing-2xl;
    background: $background-secondary;
    border-top: 1px solid $border-light;
    gap: $spacing-lg;

    @media (max-width: 768px) {
      flex-direction: column;
      align-items: stretch;
    }

    .footer-stats {
      @include flex-start;
      gap: $spacing-xl;
      flex-wrap: wrap;

      @media (max-width: 768px) {
        justify-content: center;
      }

      .stat-item {
        @include flex-start;
        gap: $spacing-xs;
        font-size: $font-size-sm;
        color: $text-secondary;

        .stat-icon {
          font-size: 16px;
          color: $primary-blue;
        }
      }
    }

    .footer-actions {
      @include flex-start;
      gap: $spacing-sm;
    }
  }
}

// ==========================================
// RESPONSIVE DESIGN
// ==========================================

@media (max-width: 1024px) {
  .json-content-wrapper {
    .table-container {
      max-height: 60vh;
    }

    .schema-panel .schema-content .schema-fields .field-grid {
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }
  }
}

@media (max-width: 768px) {
  .json-content-wrapper {
    border-radius: 0;
    
    .table-controls {
      padding: $spacing-lg;

      .view-controls {
        gap: $spacing-sm;
      }
    }

    .table-container {
      max-height: 50vh;

      .data-table .table-header-row .header-cell,
      .data-table .table-data-row .cell {
        padding: $spacing-sm $spacing-xs;
        font-size: $font-size-sm;
      }

      // Responsive nested content
      .data-table .table-data-row .cell {
        &.cell--nested {
          .expanded-nested-content .nested-card {
            ::ng-deep {
              .mat-mdc-card-header,
              .mat-mdc-card-content {
                padding: $spacing-sm;
              }
            }
          }
        }

        &.cell--array {
          .expanded-array-content {
            padding: $spacing-sm;
            max-height: 150px;
          }
        }
      }
    }

    .schema-panel ::ng-deep .mat-expansion-panel-content .mat-expansion-panel-body {
      padding: $spacing-lg;
    }

    .table-footer {
      padding: $spacing-lg;
    }
  }
}

@media (max-width: 480px) {
  .json-content-wrapper {
    .table-controls {
      .controls-right {
        flex-direction: column;
        align-items: stretch;
        gap: $spacing-md;
      }

      .view-controls {
        flex-direction: column;
        gap: $spacing-sm;
      }
    }

    .table-container {
      max-height: 40vh;
    }

    .table-footer .footer-stats {
      flex-direction: column;
      gap: $spacing-sm;
    }
  }
}

// ==========================================
// ACCESSIBILITY & FOCUS STATES
// ==========================================

button:focus,
.mat-mdc-button:focus,
.mat-mdc-icon-button:focus {
  outline: 2px solid $primary-blue;
  outline-offset: 2px;
}

// High contrast mode support
@media (prefers-contrast: high) {
  .json-content-wrapper {
    border: 2px solid $text-primary;

    .table-container .data-table .table-header-row .header-cell {
      border-bottom: 3px solid $primary-blue;
    }
  }
}

// Reduced motion support
@media (prefers-reduced-motion: reduce) {
  * {
    transition: none !important;
    animation: none !important;
  }
}

// ==========================================
// PRINT STYLES
// ==========================================

@media print {
  .json-content-wrapper {
    box-shadow: none;
    border: 1px solid $border-dark;

    .table-controls,
    .schema-panel,
    .table-footer {
      display: none;
    }

    .table-container {
      max-height: none;
      overflow: visible;
    }

    // Hide expanded content in print
    .expanded-array-content,
    .expanded-nested-content {
      display: none;
    }
  }
}