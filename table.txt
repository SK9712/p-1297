import { Component, Input, OnInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { JsonContentComponent } from './json-content.component';
import { NestedJsonTreeComponent } from './nested-json-tree.component';
import { convertNewLineSeparatedToArray } from './newline-array-converter';

export type ViewMode = 'table' | 'tree' | 'raw';

export interface FileData {
  name: string;
  size: number;
  lastModified: string;
  fileType: string;
  fileFormat: string;
  content?: string[];
  requestedFileContents?: string;
  recordCount?: number;
  recLength?: number;
  startIndex?: number;
}

@Component({
  selector: 'app-enhanced-file-viewer',
  standalone: true,
  imports: [
    CommonModule,
    MatButtonToggleModule,
    MatIconModule,
    MatButtonModule,
    MatCardModule,
    MatTooltipModule,
    MatProgressSpinnerModule,
    JsonContentComponent,
    NestedJsonTreeComponent
  ],
  template: `
    <div class="file-viewer-container">
      <!-- File Information Header -->
      <mat-card class="file-info-card" *ngIf="fileData">
        <mat-card-header>
          <div class="file-header">
            <div class="file-details">
              <h2 class="file-name">
                <mat-icon>description</mat-icon>
                {{ fileData.name }}
              </h2>
              <div class="file-meta">
                <span class="meta-item">
                  <mat-icon>storage</mat-icon>
                  {{ formatFileSize(fileData.size) }}
                </span>
                <span class="meta-item">
                  <mat-icon>schedule</mat-icon>
                  {{ formatDate(fileData.lastModified) }}
                </span>
                <span class="meta-item">
                  <mat-icon>category</mat-icon>
                  {{ fileData.fileFormat || 'AVRO' }}
                </span>
                <span class="meta-item" *ngIf="fileData.recordCount">
                  <mat-icon>table_rows</mat-icon>
                  {{ fileData.recordCount }} records
                </span>
              </div>
            </div>
            
            <!-- View Mode Toggle -->
            <div class="view-controls">
              <mat-button-toggle-group [(value)]="viewMode" (change)="onViewModeChange()">
                <mat-button-toggle value="table" matTooltip="Tabular view for flat data analysis">
                  <mat-icon>table_view</mat-icon>
                  Table
                </mat-button-toggle>
                <mat-button-toggle value="tree" matTooltip="Hierarchical view for nested data exploration">
                  <mat-icon>account_tree</mat-icon>
                  Tree
                </mat-button-toggle>
                <mat-button-toggle value="raw" matTooltip="Raw JSON view for technical analysis">
                  <mat-icon>code</mat-icon>
                  Raw
                </mat-button-toggle>
              </mat-button-toggle-group>
            </div>
          </div>
        </mat-card-header>
      </mat-card>

      <!-- Loading State -->
      <div class="loading-container" *ngIf="isProcessing">
        <mat-spinner diameter="48"></mat-spinner>
        <p>Processing AVRO data...</p>
      </div>

      <!-- Error State -->
      <mat-card class="error-card" *ngIf="error && !isProcessing">
        <mat-card-content>
          <div class="error-content">
            <mat-icon class="error-icon">error</mat-icon>
            <h3>Processing Error</h3>
            <p>{{ error }}</p>
            <button mat-raised-button color="primary" (click)="retryProcessing()">
              <mat-icon>refresh</mat-icon>
              Retry
            </button>
          </div>
        </mat-card-content>
      </mat-card>

      <!-- Data Views -->
      <div class="data-container" *ngIf="!isProcessing && !error && processedData.length > 0">
        
        <!-- Table View -->
        <app-json-content 
          *ngIf="viewMode === 'table'"
          [jsonData]="processedData"
          [startIndex]="fileData?.startIndex"
          [pageSize]="25"
          [pageSizeOptions]="[10, 25, 50, 100, 200]"
          [enableSearch]="true"
          [enableExport]="true"
          [showSchemaPanel]="true"
          class="table-view">
        </app-json-content>

        <!-- Tree View -->
        <app-nested-json-tree 
          *ngIf="viewMode === 'tree'"
          [jsonData]="getTreeData()"
          class="tree-view">
        </app-nested-json-tree>

        <!-- Raw JSON View -->
        <div *ngIf="viewMode === 'raw'" class="raw-view">
          <div class="raw-header">
            <h3>Raw JSON Data</h3>
            <div class="raw-actions">
              <button mat-button (click)="copyToClipboard()">
                <mat-icon>content_copy</mat-icon>
                Copy
              </button>
              <button mat-button (click)="downloadRawJson()">
                <mat-icon>file_download</mat-icon>
                Download
              </button>
              <button mat-button (click)="formatJson()">
                <mat-icon>code</mat-icon>
                {{ isFormatted ? 'Minify' : 'Format' }}
              </button>
            </div>
          </div>
          <pre class="json-display" [innerHTML]="formattedJson"></pre>
        </div>
      </div>

      <!-- Empty State -->
      <mat-card class="empty-card" *ngIf="!isProcessing && !error && processedData.length === 0">
        <mat-card-content>
          <div class="empty-content">
            <mat-icon class="empty-icon">folder_open</mat-icon>
            <h3>No Data Available</h3>
            <p>This file appears to be empty or could not be processed.</p>
          </div>
        </mat-card-content>
      </mat-card>

      <!-- Data Statistics -->
      <mat-card class="stats-card" *ngIf="!isProcessing && !error && processedData.length > 0">
        <mat-card-header>
          <mat-card-title>
            <mat-icon>analytics</mat-icon>
            Data Analysis
          </mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <div class="stats-grid">
            <div class="stat-item">
              <span class="stat-label">Records Processed:</span>
              <span class="stat-value">{{ processedData.length }}</span>
            </div>
            <div class="stat-item" *ngIf="fileData?.startIndex && fileData.startIndex > 1">
              <span class="stat-label">Starting From:</span>
              <span class="stat-value">Record #{{ fileData.startIndex }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Data Complexity:</span>
              <span class="stat-value">{{ getComplexityLevel() }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Recommended View:</span>
              <span class="stat-value">{{ getRecommendedView() }}</span>
            </div>
          </div>
        </mat-card-content>
      </mat-card>
    </div>
  `,
  styles: [`
    .file-viewer-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
      background: #f8f9fa;
      min-height: 100vh;
    }

    .file-info-card {
      .file-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        gap: 20px;

        @media (max-width: 768px) {
          flex-direction: column;
          gap: 16px;
        }
      }

      .file-details {
        flex: 1;
      }

      .file-name {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0 0 12px 0;
        color: #212529;
        font-size: 20px;
        font-weight: 600;
      }

      .file-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;

        .meta-item {
          display: flex;
          align-items: center;
          gap: 4px;
          color: #6c757d;
          font-size: 14px;

          mat-icon {
            font-size: 16px;
            width: 16px;
            height: 16px;
          }
        }
      }

      .view-controls {
        .mat-button-toggle-group {
          background: white;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mat-button-toggle {
          display: flex;
          flex-direction: column;
          gap: 4px;
          padding: 12px 16px;
          border: none;

          mat-icon {
            font-size: 18px;
          }
        }
      }
    }

    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px;
      gap: 20px;

      p {
        color: #6c757d;
        margin: 0;
      }
    }

    .error-card, .empty-card {
      .error-content, .empty-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 40px;

        .error-icon, .empty-icon {
          font-size: 64px;
          width: 64px;
          height: 64px;
          margin-bottom: 16px;
        }

        .error-icon {
          color: #dc3545;
        }

        .empty-icon {
          color: #6c757d;
        }

        h3 {
          margin: 0 0 12px 0;
          color: #212529;
        }

        p {
          margin: 0 0 20px 0;
          color: #6c757d;
          max-width: 400px;
        }
      }
    }

    .data-container {
      .table-view, .tree-view {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .raw-view {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        overflow: hidden;

        .raw-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 16px 20px;
          background: #f8f9fa;
          border-bottom: 1px solid #e9ecef;

          h3 {
            margin: 0;
            color: #495057;
          }

          .raw-actions {
            display: flex;
            gap: 8px;
          }
        }

        .json-display {
          padding: 20px;
          margin: 0;
          background: #f8f9fa;
          border: none;
          font-family: 'Roboto Mono', monospace;
          font-size: 12px;
          line-height: 1.4;
          max-height: 70vh;
          overflow: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
        }
      }
    }

    .stats-card {
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;

        .stat-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 12px 16px;
          background: #f8f9fa;
          border-radius: 6px;
          border: 1px solid #e9ecef;

          .stat-label {
            color: #6c757d;
            font-size: 14px;
          }

          .stat-value {
            color: #495057;
            font-weight: 600;
            font-size: 14px;
          }
        }
      }
    }

    @media (max-width: 768px) {
      .file-viewer-container {
        padding: 12px;
      }

      .stats-card .stats-grid {
        grid-template-columns: 1fr;
      }
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class EnhancedFileViewerComponent implements OnInit {
  @Input() fileData: FileData | null = null;

  viewMode: ViewMode = 'tree'; // Default to tree for AVRO data
  processedData: any[] = [];
  isProcessing = false;
  error: string | null = null;
  formattedJson = '';
  isFormatted = true;

  constructor(private cdr: ChangeDetectorRef) {}

  ngOnInit(): void {
    if (this.fileData) {
      this.processFileData();
    }
  }

  private async processFileData(): Promise<void> {
    if (!this.fileData) return;

    this.isProcessing = true;
    this.error = null;
    this.cdr.markForCheck();

    try {
      // Process AVRO data based on available content
      if (this.fileData.requestedFileContents) {
        // Handle escaped JSON string format
        this.processedData = convertNewLineSeparatedToArray(this.fileData.requestedFileContents);
      } else if (this.fileData.content && Array.isArray(this.fileData.content)) {
        // Handle array of JSON strings
        this.processedData = this.fileData.content
          .map((jsonStr, index) => {
            try {
              return JSON.parse(jsonStr);
            } catch (error) {
              console.warn(`Failed to parse JSON at index ${index}:`, error);
              return {
                _parseError: true,
                _index: index,
                _originalString: jsonStr
              };
            }
          });
      }

      // Apply startIndex if specified
      if (this.fileData.startIndex && this.fileData.startIndex > 1) {
        const startIdx = this.fileData.startIndex - 1; // Convert to 0-based
        this.processedData = this.processedData.slice(startIdx);
      }

      // Generate formatted JSON for raw view
      this.updateFormattedJson();

      // Auto-select optimal view mode based on data complexity
      this.viewMode = this.getRecommendedViewMode();

    } catch (error) {
      this.error = `Failed to process file data: ${error instanceof Error ? error.message : 'Unknown error'}`;
      console.error('File processing error:', error);
    } finally {
      this.isProcessing = false;
      this.cdr.markForCheck();
    }
  }

  private getRecommendedViewMode(): ViewMode {
    if (this.processedData.length === 0) return 'raw';
    
    // Check for nested structures
    const hasNestedData = this.processedData.some(record => 
      typeof record === 'object' && record !== null && 
      Object.values(record).some(value => 
        typeof value === 'object' || Array.isArray(value)
      )
    );

    return hasNestedData ? 'tree' : 'table';
  }

  onViewModeChange(): void {
    if (this.viewMode === 'raw') {
      this.updateFormattedJson();
    }
    this.cdr.markForCheck();
  }

  getTreeData(): any {
    // For tree view, pass the processed data
    return this.processedData;
  }

  private updateFormattedJson(): void {
    if (this.processedData.length === 0) {
      this.formattedJson = '[]';
      return;
    }

    const data = this.processedData.length === 1 ? this.processedData[0] : this.processedData;
    
    if (this.isFormatted) {
      this.formattedJson = this.syntaxHighlight(JSON.stringify(data, null, 2));
    } else {
      this.formattedJson = JSON.stringify(data);
    }
  }

  private syntaxHighlight(json: string): string {
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, 
      (match) => {
        let cls = 'number';
        if (/^"/.test(match)) {
          if (/:$/.test(match)) {
            cls = 'key';
          } else {
            cls = 'string';
          }
        } else if (/true|false/.test(match)) {
          cls = 'boolean';
        } else if (/null/.test(match)) {
          cls = 'null';
        }
        return `<span class="${cls}">${match}</span>`;
      });
  }

  formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  formatDate(dateString: string): string {
    try {
      return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch {
      return dateString;
    }
  }

  getComplexityLevel(): string {
    if (this.processedData.length === 0) return 'Unknown';
    
    const sampleRecord = this.processedData[0];
    if (typeof sampleRecord !== 'object') return 'Simple';
    
    const hasNested = Object.values(sampleRecord).some(value => 
      typeof value === 'object' || Array.isArray(value)
    );
    
    const fieldCount = Object.keys(sampleRecord).length;
    
    if (hasNested && fieldCount > 10) return 'Highly Complex';
    if (hasNested || fieldCount > 8) return 'Moderate';
    return 'Simple';
  }

  getRecommendedView(): string {
    const complexity = this.getComplexityLevel();
    switch (complexity) {
      case 'Highly Complex': return 'Tree View';
      case 'Moderate': return 'Tree or Table';
      default: return 'Table View';
    }
  }

  retryProcessing(): void {
    this.processFileData();
  }

  copyToClipboard(): void {
    const data = this.processedData.length === 1 ? this.processedData[0] : this.processedData;
    navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
      console.log('Copied to clipboard');
    });
  }

  downloadRawJson(): void {
    const data = this.processedData.length === 1 ? this.processedData[0] : this.processedData;
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${this.fileData?.name || 'data'}-processed.json`;
    link.click();
    URL.revokeObjectURL(url);
  }

  formatJson(): void {
    this.isFormatted = !this.isFormatted;
    this.updateFormattedJson();
    this.cdr.markForCheck();
  }
}